# [小端字节序与大端字节序](https://www.cnblogs.com/onepixel/p/7468343.html)

在各种计算机体系结构中，对于字节、字等的存储机制有所不同，因而引发了计算机通信领域中一个很重要的问题，即通信双方交流的信息单元（比特、字节、字、双字等等）应该以什么样的顺序进行传送。如果不达成一致的规则，通信双方将无法进行正确的编/译码从而导致通信失败。

目前在各种体系的计算机中通常采用的字节存储机制主要有两种：Big-Endian 和 Little-Endian，下面先从字节序说起。

### **1、什么是字节序**

**字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序(一个字节的数据当然就无需谈顺序的问题了)**。

字节序分为两类：Big-Endian 和 Little-Endian，引用标准的 Big-Endian 和 Little-Endian 的定义如下：

- Little-Endian：就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。
- Big-Endian：就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。
- 网络字节序：TCP/IP各层协议将字节序定义为 Big-Endian（这与主机序相反），因此TCP/IP协议中使用的字节序通常称之为网络字节序。

#### **1.1 什么是高/低地址端**

首先我们要知道我们 C 程序映像中内存的空间布局情况：在《C专家编程》中或者《Unix环境高级编程》中有关于内存空间布局情况的说明，大致如下图：
**----------------------- 最高内存地址 0xffffffff
栈底
栈
栈顶
-----------------------**

**NULL (空洞) 
\-----------------------
堆
\-----------------------
未初始化的数据
----------------------- 统称数据段
初始化的数据
\-----------------------
正文段(代码段)
----------------------- 最低内存地址 0x00000000**

以上图为例如果我们在栈上分配一个unsigned char buf[4]，那么这个数组变量在栈上是如何布局的呢？看下图：
**栈底 （高地址）
\----------
buf[3] 
buf[2]
buf[1]
buf[0]
\----------
栈顶（低地址）**

#### **1.2 什么是高/低字节**

现在我们弄清了高/低地址，接着考虑高/低字节。有些文章中称低位字节为最低有效位，高位字节为最高有效位。如果我们有一个32位无符号整型 0x12345678，那么高位是什么，低位又是什么呢？其实很简单。在十进制中我们都说靠左边的是高位，靠右边的是低位，在其他进制也是如此。就拿 0x12345678 来说，从高位到低位的字节依次是 0x12、0x34、0x56 和 0x78。
高/低地址端和高/低字节都弄清了。我们再来回顾一下 Big-Endian 和 Little-Endian 的定义，并用图示说明两种字节序：
以unsigned int value = 0x12345678 为例，分别看看在两种字节序下其存储情况，我们可以用 unsignedchar buf[4] 来表示 value：

**Big-Endian: 低地址存放高位**，如下图：
**栈底 （高地址）**
\---------------
**buf[3] (0x78) -- 低位**
buf[2] (0x56)
buf[1] (0x34)
**buf[0] (0x12) -- 高位**
\---------------
**栈顶 （低地址）**

**Little-Endian: 低地址存放低位**，如下图：
**栈底 （高地址）**
\---------------
**buf[3] (0x12) -- 高位**
buf[2] (0x34)
buf[1] (0x56)
**buf[0] (0x78) -- 低位**
\--------------
**栈 顶 （低地址）**

### 2、各种 Endian

#### **2.1 Big-Endian**

计算机体系结构中一种描述多字节存储顺序的术语，在这种机制中最重要字节（MSB）存放在最低端的地址 上。采用这种机制的处理器有 IBM3700系列、PDP-10、Mortolora 微处理器系列和绝大多数的 RISC 处理器。
+----------+
| 0x34 |<-- 0x00000021
+----------+
| 0x12 |<-- 0x00000020
+----------+
图 1：双字节数 0x1234 以 Big-Endian 的方式存在起始地址 0x00000020 中

**在Big-Endian中，对于bit序列中的序号编排方式如下**（以双字节数 0x**8B8A** 为例）：
**bit 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15**
+-----------------------------------------+
**val | 1 0 0 0 1 0 1 1 | 1 0 0 0 1 0 1 0 |**
+----------------------------------------+
图 2：**Big-Endian的**bit序列编码方式

#### **2.2 Little-Endian**

计算机体系结构中一种描述多字节存储顺序的术语，在这种机制中**最不重要字节（LSB）存放在最低端的地址上**。采用这种机制的处理器有PDP-11、VAX、Intel系列微处理器和一些网络通信设备。该术语除了描述多字节存储顺序外还常常用来描述一个字节中各个比特的排放次序。

+----------+
| 0x12 |<-- 0x00000021
+----------+
| 0x**34** |<-- **0x00000020
**+----------+

图3：双字节数0x1234以 Little-Endian 的方式存在起始地址 0x00000020 中

在 Little-Endian中，对于**bit序列中的序号编排和Big-Endian刚好相反**，其方式如下（**以双字节数0x8B8A为例**）：

**bit 15 14 13 12 11 10 9 8 7 65 4 3 2 1 0**
+-----------------------------------------+
**val | 1 0 0 0 1 0 1 1 | 1 0 0 0 1 0 1 0 |**
+-----------------------------------------+
图 4：Little-Endian的bit序列编码方式

注2：通常我们说的主机序（Host Order）就是遵循 Little-Endian 规则。所以当两台主机之间要通过TCP/IP协议进行通信的时候就需要调用相应的函数进行主机序（Little-Endian）和网络序（Big-Endian）的转换。

注3：正因为这两种机制对于同一bit序列的序号编排方式恰恰相反，所以《现代英汉词典》中对MSB的翻译为“最高有效位”欠妥，故本文定义为“最重要的bit/byte”。

#### **2.3 Middle-Endian**

除了Big-Endian和Little-Endian之外的多字节存储顺序就是Middle- Endian，比如以4个字节为例：象以3-4-1-2或者2-1-4-3这样的顺序存储的就是Middle-Endian。这种存储顺序偶尔会在一些小型机体系中的十进制数的压缩格式中出现。

嵌入式系统开发者应该对Little-endian和Big-endian模式非常了解。采用 Little-endian模式的CPU对操作数的存放方式是从低字节到高字节，而Big-endian模式对操作数的存放方式是从高字节到低字节。 32bit宽的数0x12345678在Little-endian模式CPU内存中的存放方式（假设从地址0x4000开始存放）为： 

![img](https://images2017.cnblogs.com/blog/849589/201709/849589-20170902232317671-147427130.png)

### **3、优缺点**

**Big-Endian 优点：**靠首先提取高位字节，你总是可以由看看在偏移位置为0的字节来确定这个数字是正数还是负数。你不必知道这个数值有多长，或者你也不必过一些字节来看这个数值是否含有符号位。这个数值是以它们被打印出来的顺序存放的，所以从二进制到十进制的函数特别有效。因而，对于不同要求的机器，在设计存取方式时就会不同。

**Little-Endian 优点：**提取一个，两个，四个或者更长字节数据的汇编指令以与其他所有格式相同的方式进行：首先在偏移地址为0的地方提取最低位的字节，因为地址偏移和字节数是一对一的关系，多重精度的数学函数就相对地容易写了。

如果你增加数字的值，你可能在左边增加数字（高位非指数函数需要更多的数字）。因此，经常需要增加两位数字并移动存储器里所有Big-endian顺序的数字，把所有数向右移，这会增加计算机的工作量。不过，使用Little- Endian的存储器中不重要的字节可以存在它原来的位置，新的数可以存在它的右边的高位地址里。这就意味着计算机中的某些计算可以变得更加简单和快速。

### 4、网络字节顺序

1、**字节内的比特位不受这种顺序的影响**
比如一个字节 1000 0000 （或表示为十六进制 80H)不管是什么顺序其内存中的表示法都是这样。

2、**大于1个字节的数据类型才有字节顺序问题
**比如 Byte A，这个变量只有一个字节的长度，所以根据上一条没有字节顺序问题。所以字节顺序是“字节之间的相对顺序”的意思。

3、**大于1个字节的数据类型的字节顺序有两种**
比如 short B，这是一个两字节的数据类型，这时就有字节之间的相对顺序问题了。
**网络字节顺序是“所见即所得”的顺序**。而Intel类型的CPU的字节顺序与此相反。
比如上面的 short B=0102H(十六进制，每两位表示一个字节的宽度）。所见到的是“0102”，按一般数学常识，数轴从左到右的方向增加，即内存地址从左到右增加的话，在内存中这个 short B的字节顺序是：
01 02
这就是网络字节顺序。所见到的顺序和在内存中的顺序是一致的！
**假设通过抓包得到网络数据的两个字节流为：01 02**

**而相反的字节顺序就不同了，其在内存中的顺序为：02 01
**
如果这表示两个 Byte类型的变量，那么自然不需要考虑字节顺序的问题。如果这表示一个 short 变量，那么就需要考虑字节顺序问题。根据网络字节顺序“所见即所得”的规则，这个变量的值就是：0102

假设本地主机是Intel类型的，那么要表示这个变量，有点麻烦：
定义变量 short X，字节流地址为：pt，按顺序读取内存是为x=*((short*)pt);
那么X的**内存顺序**当然是 **01 02按非 “所见即所得” 的规则**，这个内存顺序和看到的一样显然是不对的，所以要把这两个字节的位置调换。调换的方法可以自己定义，但用已经有的API还是更为方便。

### 5、网络字节顺序与主机字节顺序

- 网络字节顺序NBO（Network Byte Order）：按从高到低的顺序存储，在网络上使用统一的网络字节顺序，可以避免兼容性问题。
- 主机字节顺序（HBO，Host Byte Order）：不同的机器HBO不相同，与CPU设计有关计算机数据存储有两种字节优先顺序：高位字节优先和低位字节优先。Internet上数据以高位字节优先顺序在网络上传输，所以对于在内部是以低位字节优先方式存储数据的机器，在Internet上传输数据时就需要进行转换。 