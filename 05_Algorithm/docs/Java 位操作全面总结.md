# [Java 位操作全面总结](https://www.jianshu.com/p/b677858bc085)

在计算机中所有数据都是以二进制的形式储存的。位运算其实就是直接对在内存中的二进制数据进行操作，因此处理数据的速度非常快。

## 位操作基础

基本的位操作符有与、或、异或、取反、左移、右移这6种，它们的运算规则如下所示：

| 符号 | 描述 |                           运算规则                           |
| :--: | :--: | :----------------------------------------------------------: |
|  &   |  与  |                 两个位都为 1 时，结果才为 1                  |
|  I   |  或  |                 两个位都是 0 时，结果才为 0                  |
|  ^   | 异或 |                  两个位相同时为 0，相异为 1                  |
|  ~   | 取反 |                        0 变 1，1 变 0                        |
|  <<  | 左移 |          各二进位全部左移若干位，高位丢弃，低位补 0          |
|  >>  | 右移 | 各二进位全部右移若干位，对无符号数，高位补 0，有符号数，各编译器处理方法不一样，有的补符号位(算术右移)，有的补 0 (逻辑右移) |

注意以下几点:

- 在这6种操作符，只有 `~` 取反是单目操作符，其它5种都是双目操作符。
- 位操作只能用于整形数据，对 `float` 和 `double` 类型进行位操作会被编译器报错。
- 位操作符的运算优先级比较低，因为尽量使用括号来确保运算顺序，否则很可能会得到莫明其妙的结果。比如要得到像 1，3，5，9 这些 2^i+1 的数字。写成 `int a = 1 << i + 1;` 是不对的，程序会先执行 `i + 1`，再执行左移操作。应该写成 `int a = (1 << i) + 1;`
- 另外位操作还有一些复合操作符，如 &=、|=、 ^=、<<=、>>=

```java
public class BitMain {

    public static void main(String [] args) {
        int a = -15, b = 15;
        
        // -15 = [1111 0001]补，右移二位，最高位由符号位填充将得到 [1111 1100]补 即 -4
        System.out.println(a >> 2); // -4
        
        // 15= [0000 1111]补，右移二位，最高位由符号位填充将得到 [0000 0011] 即 3
        System.out.println(b >> 2); // 3：
    }
}
```

## 常用位操作小技巧

下面对位操作的一些常见应用作个总结，有判断奇偶、交换两数、变换符号及求绝对值。这些小技巧应用易记，应当熟练掌握。

### 判断奇偶数

**只要根据最未位是 0 还是 1 来决定，为 0 就是偶数，为 1 就是奇数。** 因此可以用 `if ((a & 1) == 0)` 代替 `if (a % 2 == 0)` 来判断 a 是不是偶数。下面程序将输出 0 到 100 之间的所有偶数：

```java
    for (int i = 0; i < 100; i ++) {
        if ((i & 1) == 0) { // 偶数
            System.out.println(i);
        }
    }
```

### 交换两数

```java
int a = 1, b = 2;
a ^= b;
b ^= a;
a ^= b;

System.out.println("a  = " + a);
System.out.println("b = " + b);
```

log 信息:

```xml
a  = 2
b = 1
```

可以这样理解：

- 第一步 a ^= b 即 a = (a ^ b)；
- 第二步 b ^= a 即 b= b ^ ( a ^ b)，由于异或运算满足交换律，b ^ ( a ^ b) = b ^ b ^ a。**由于一个数和自己异或的结果为 0 并且任何数与 0 异或都会不变的**，所以此时 b 被赋上了 a 的值；
- 第三步 a ^= b 就是 a = a ^ b，由于前面二步可知 a = ( a ^ b)，b=a，所以 a = a ^ b 即 a = ( a ^ b ) ^ a。故 a 会被赋上 b 的值。

### 变换符号

变换符号就是正数变成负数，负数变成正数。 如对于 -11 和 11，可以通过下面的变换方法将 -11 变成 11

```xml
// 11
[0000 1011]补 --> 取反(~) --> [1111 0100] --> 加 1 --> [1111 0101]补( -11 )

// -11
[1111 0101]补 --> 取反(~) --> [0000 1010] --> 加 1 --> [0000 1011]补( 11 )
```

因此变换符号只需要取反操作后加 1 即可

```java
int a = -15, b = 15;
System.out.println(~a + 1);
System.out.println(~b + 1);
```

### 求绝对值

位操作也可以用来求绝对值，对于负数可以通过上面**变换符号**方式对其取反后加1来得到正数。
 因此先移位来取符号位，`int i = a >> 31;` **要注意如果 a 为正数，i 等于 0，为负数，i 等于 -1。**然后对i进行判断——如果i等于0，直接返回。否之，返回~a+1。完整代码如下：

```java
int i = a >> 31;
System.out.println(i == 0 ? a : (~a + 1));
```

现在再分析下。对于任何数，与 0 异或都会保持不变，与 -1 即 `0xFFFFFFFF` 异或就相当于取反。因此，a 与 i 异或后再减 i（因为 i 为 0 或 -1，所以减 i即是要么加 0要么加 1）也可以得到绝对值。所以可以对上面代码优化下：

```java
int j = a >> 31;
System.out.println((a ^ j) - j);
```

**注意这种方法没用任何判断表达式.**

### 位操作与空间压缩

筛素数(质数)法在这里不就详细介绍了，本文着重对筛素数法所使用的素数表进行优化来减小其空间占用。要压缩素数表的空间占用，可以使用位操作。下面是用筛素数法计算100以内的素数示例代码：

```java
int max = 100;
boolean[] flags = new boolean[max];
int [] primes = new int[max / 3 + 1];
int pi = 0;

for (int m = 2; m < max ; m ++) {
    if (!flags[m]) {
        primes[pi++] = m;
        for(int n = m; n < max; n += m) {
            flags[n] = true;
        }
    }
}

System.out.println(Arrays.toString(primes));
```

log 信息为

```xml
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

在上面程序是用bool数组来作标记的，bool型数据占1个字节（8位），因此用位操作来压缩下空间占用将会使空间的占用减少八分之七。

下面考虑下如何在数组中对指定位置置1，先考虑如何对一个整数在指定位置上置1。对于一个整数可以通过将 1 向左移位后与其相或来达到在指定位上置1的效果，代码如下所示：

```java
// 在一个数指定位上置1
int e = 0;
e |=  1 << 10;
System.out.println(e);
```

同样，可以1向左移位后与原数相与来判断指定位上是0还是1（也可以将原数右移若干位再与1相与）。

```java
//判断指定位上是0还是1
if ((e & (1 << 10)) != 0)
    System.out.println("指定位上为1");
else
    System.out.println("指定位上为0");
```

扩展到数组上，我们可以采用这种方法，因为数组在内存上也是连续分配的一段空间，完全可以“认为”是一个很长的整数。先写一份测试代码，看看如何在数组中使用位操作：

```java
int[] bits = new int[40 / 32 + 1];
for (int m = 0; m < 40; m += 3) {
    bits[m / 32] |= (1 << (m % 32));
}
// 输出整个bits
for (int m = 0; m < 40; m++) {
    if (((bits[m / 32] >> (m % 32)) & 1) != 0)
        System.out.print('1');
    else
        System.out.print('0');
}
```

log 信息

```xml
1001001001001001001001001001001001001001
```

可以看出该数组每 3 个就置成了 1，证明我们上面对数组进行位操作的方法是正确的。因此可以将上面筛素数方法改成使用位操作压缩后的筛素数方法：

```java
int[] flags2 = new int[max / 32 + 1];
int [] primes = new int[max / 3 + 1];
pi = 0;
for (int m = 2; m < max ; m ++) {
    if ((((flags2[m / 32] >> (m % 32)) & 1) == 0)) {
        primes[pi++] = m;
        for(int n = m; n < max; n += m) {
            flags2[n / 32] |= (1 << (n % 32));
        }
    }
}

System.out.println(Arrays.toString(primes));
```

log 信息为

```xml
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

## 位操作技巧

```java
// 1. 获得int型最大值
System.out.println((1 << 31) - 1);// 2147483647， 由于优先级关系，括号不可省略
System.out.println(~(1 << 31));// 2147483647

// 2. 获得int型最小值
System.out.println(1 << 31);
System.out.println(1 << -1);

// 3. 获得long类型的最大值
System.out.println(((long)1 << 127) - 1);

// 4. 乘以2运算
System.out.println(10<<1);

// 5. 除以2运算(负奇数的运算不可用)
System.out.println(10>>1);

// 6. 乘以2的m次方
System.out.println(10<<2);

// 7. 除以2的m次方
System.out.println(16>>2);

// 8. 判断一个数的奇偶性
System.out.println((10 & 1) == 1);
System.out.println((9 & 1) == 1);

// 9. 不用临时变量交换两个数（面试常考）
a ^= b;
b ^= a;
a ^= b;

// 10. 取绝对值（某些机器上，效率比n>0 ? n:-n 高）
int n = -1;
System.out.println((n ^ (n >> 31)) - (n >> 31));
/* n>>31 取得n的符号，若n为正数，n>>31等于0，若n为负数，n>>31等于-1
若n为正数 n^0-0数不变，若n为负数n^-1 需要计算n和-1的补码，异或后再取补码，
结果n变号并且绝对值减1，再减去-1就是绝对值 */

// 11. 取两个数的最大值（某些机器上，效率比a>b ? a:b高）
System.out.println(b&((a-b)>>31) | a&(~(a-b)>>31));

// 12. 取两个数的最小值（某些机器上，效率比a>b ? b:a高）
System.out.println(a&((a-b)>>31) | b&(~(a-b)>>31));

// 13. 判断符号是否相同(true 表示 x和y有相同的符号， false表示x，y有相反的符号。)
System.out.println((a ^ b) > 0);

// 14. 计算2的n次方 n > 0
System.out.println(2<<(n-1));

// 15. 判断一个数n是不是2的幂
System.out.println((n & (n - 1)) == 0);
/*如果是2的幂，n一定是100... n-1就是1111....
所以做与运算结果为0*/

// 16. 求两个整数的平均值
System.out.println((a+b) >> 1);

// 17. 从低位到高位,取n的第m位
int m = 2;
System.out.println((n >> (m-1)) & 1);

// 18. 从低位到高位.将n的第m位置为1
System.out.println(n | (1<<(m-1)));
/*将1左移m-1位找到第m位，得到000...1...000
n在和这个数做或运算*/

// 19. 从低位到高位,将n的第m位置为0
System.out.println(n & ~(0<<(m-1)));
/* 将1左移m-1位找到第m位，取反后变成111...0...1111
n再和这个数做与运算*/
```

