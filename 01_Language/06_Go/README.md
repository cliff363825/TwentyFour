# 语言篇之Go

## 数据类型

1. 基本数据类型
    1. 数值型
        1. 整数类型
           1. int，int8，int16，int32，int64
           2. uint，uint8，uint16，uint32，unit64
           3. byte（type byte = uint8）
        2. 浮点类型：float32，float64
    3. 布尔型：bool
    4. 字符串：string
    
2. 派生/复杂数据类型
  
    1. 数组：var arr [LEN]int
    2. 指针：var ptr *int = nil
    3. 切片：var s = make([]int, LEN, CAP)
    4. 映射：var map = make(map[int]int, CAP)
    5. 管道：var ch = make(chan int, CAP)
    6. 函数：var f func(int, int) int = nil
    7. 接口：var obj interface{}
    8. 结构体：type Point struct {X int, Y int}
    
3. 基本数据类型的默认值

    | 数据类型                        | 默认值                        |
    | ------------------------------- | ----------------------------- |
    | 整形（int系列，uint系列，byte） | 0                             |
    | 浮点型（float系列）             | 0                             |
    | 字符串（string）                | ""                            |
    | 布尔类型（bool）                | false                         |
    | 数组                            | [...]数据类型{数据类型默认值} |
    | 结构体                          | 属性的数据类型的默认值        |
    | 引用类型                        | nil                           |

4. 基本数据类型的相互转换

    1. Golang 和 java/c 不同，Go 在不同类型的变量之间赋值是需要显式转换。也就是说 Golang 中数据类型不能自动转换。

5. 指针
    1. 基本介绍
        1. 基本数据类型，变量存的就是值，也叫值类型。
        2. 获取变量的地址，用 &，比如: var num int，获取 num 的地址 &num。
        3. 指针类型，指针变量存的是一个地址，这个地址指向的空间存的才是值。比如：var ptr *int = &num
        4. 获取指针类型所指向的值，使用: *，比如: var ptr *int，使用 *ptr 获取 ptr 指向的值
    2. 指针的使用细节
        1. 值类型，都有对应的指针类型，形式为 *数据类型，比如 int 的对应的指针就是 *int，float32 对应的指针类型就是 *float32，依此类推。
        2. 值类型包括：基本数据类型 int 系列，float 系列，bool，string，数组 和 结构体(struct)

6. 值类型和引用类型
    1. 值类型和引用类型的说明
        1. 值类型：基本数据类型 int 系列，float 系列，bool，string，数组 和 结构体(struct)
        2. 引用类型：指针、slice切片、map、管道chan、interface 等都是引用类型
    2. 值类型和引用类型的使用特点
        1. 值类型：变量直接存储值，内存通常在栈中分配
        2. 引用类型：变量存储的是一个地址，这个地址对应的空间才真正存储数据（值），内存通常在堆上分配，当没有任何变量引用这个地址时，该地址对应的数据空间就成为一个垃圾，由GC来回收

## 算术运算符

1. 注意事项
    1. 对于符号 "/"，它的整数除和小数除是由区别的：整数之间做除法时，只保留整数部分而舍弃小数部分。例如：x := 19 / 5，结果是 3。
    2. Golang 的自增自减只能当作一个独立语言使用。
    3. Golang 的 ++ 和 -- 只能写在变量的后面，不能写在变量的前面，即：只有 a++ a-- 没有 ++a --a
    4. Golang 的设计者去除 c/java 中的自增自减的容易混淆的写法，让 Golang 更加简洁统一

## 函数

1. 函数使用的注意事项和细节讨论
  
    1. 函数的形参列表可以是多个，返回值列表也可以是多个。
    
        ```
        func MyFunc(a0 int, a1 int) (int, int) {...}
        ```
    
    2. 形参列表和返回值列表的数据类型可以是值类型和引用类型。
    
    3. 函数的命名遵循标识符命名规范，首字母不能是数字，首字母大写该函数可以被本包文件和其它包文件使用，类似 public，首字母小些，只能被本包文件使用，其它包文件不能使用，类似 private。
    
    4. 函数中的变量是局部的，函数外不生效。
    
    5. 基本数据类型 和 数组 默认都是值传递，即进行值拷贝。在函数内修改，不会影响到原来的值。
    
    6. 如果希望函数内的变量能修改函数外的变量（指的是默认以值传递的方式的数据类型），可以传入变量的地址&，函数内以指针的方式操作变量。从效果上看类似引用。
    
    7. Go 函数不支持函数重载。
    
    8. 在 Go 中，函数也是一种数据类型，可以赋值给一个变量，则该变量就是一个函数类型的变量了。通过该变量可以对函数调用。
        ```
        // 声明并定义一个匿名函数
        var anonymousFunc = func(a0 int, a1 int) int {
            return a0 + a1
        }
        anonymousFunc(1, 2)
        ```
    
    9. 函数既然是一种数据类型，因此在 Go 中，函数可以作为形参，并且调用。
        ```
        type funcType func(int, int) int
        func MyFunc(a0 funcType, a1 int) {...}
        ```
    
    10. 为了简化数据类型定义，Go 支持自定义数据类型。
       ```
       基本语法: type 自定义数据类型名 数据类型
       type myInt int
       type mySum func(int, int) int
       ```
    
    11. 支持对函数返回值命名
        ```
        func MyFunc(a0 int, a1 int) (sum int, sub int) {
            sum = a0 + a1
            sub = a0 - a1
            return
        }
        ```
    
    12. 使用 _ 标识符，忽略返回值。
    
    13. Go 支持可变参数。
    
        ```
        func sum(a0 int, args ...int) sum int {...}
        1. args 是 slice 切片，通过 args[index] 可以访问到各个值。
        2. 如果一个函数的形参列表中有可变参数，则可变参数需要放在形参列表最后。
        ```

2. init函数的注意事项和细节
   1. 如果一个文件同时包含全局变量定义，init 函数和 main 函数，则执行的流程 全局变量定义 -> init函数 -> main函数
   2. init 函数最主要的作用，就是完成一些初始化的工作
   3. 多个文件的执行流程

3. 函数的 defer
   1. 在函数中，程序员经常需要创建资源（比如：数据库连接、文件句柄、锁等），为了在函数执行完毕后，及时的释放资源，Go 的设计者提供 defer（延时机制）。
   2. defer 的注意事项和细节
       1. 当 go 执行到一个 defer 时，不会立即执行 defer 后的语句，而是将 defer 后的语句压入到一个栈中，然后继续执行函数下一个语句。
       2. 当函数执行完毕后，在从 defer 栈中，依次从栈顶取出语句执行（注：遵守栈的 后进先出 的机制）。
       3. 在 defer 将语句放入到栈时，也会将相关的值拷贝同时入栈。
   3. defer 的最佳实践
       1. defer 最主要的价值是在，当函数执行完毕后，可以及时的释放函数创建的资源。
       2. 在 Golang 编程中的通常做法是，创建资源后，比如（打开了文件，获取了数据库的链接，或者是锁资源），可以执行 defer file.Close()，defer connect.Close()
       3. 在 defer 后，可以继续使用创建资源。
       4. 当函数完毕后，系统会依次从 defer 栈中，取出语句，关闭资源。
       5. 这种机制，非常简洁，程序员不用再为在什么时机关闭资源而烦心。

4. 函数参数传递的方式
   1. 基本介绍
       1. 值类型 参数默认是 值传递
       2. 引用类型 参数默认是 引用传递
   2. 两种传递方式
       1. 值传递
       2. 引用传递
       3. 其实，不管是值传递还是引用传递，传递给函数的都是变量的副本，不同的是，值传递的是值的拷贝，引用传递的是地址的拷贝，一般来说，地址拷贝效率高，因为数据量少，而值拷贝决定拷贝的数据大小，数据越大，效率越低。
   3. 值类型和引用类型
       1. 值类型：基本数据类型 int 系列，float 系列，bool，string，数据 和 结构体struct
       2. 引用传递：指针，slice 切片，map，管道 chan，interface 等都是引用类型
   4. 值传递和引用传递使用特点
       1. 值类型默认是值传递：变量直接存储值，内存通常在栈中分配。
       2. 引用类型默认是引用类型：变量存储的是一个地址，这个地址对应的空间才真正存储数据（值），内存通常在堆上分配，当没有任何变量引用这个地址时，该地址对应的数据空间就成为一个垃圾，由GC来回收。
       3. 如果希望函数内的变量能修改函数外的变量，可以传入变量的地址&，函数内以指针的方式操作变量。从效果上看类似引用。

## 数组

1. 数组是多个相同类型数据的组合，一个数组一旦声明/定义了，其长度是固定的，不能动态变化。
2. var arr []int 这时 arr 就是一个 slice 切片。
3. 数组中的元素可以是任何数据类型，包括值类型和引用类型，但是不能混用。
4. 数组创建后，如果没有赋值，有默认值（零值）
    ```
    数值类型数组  默认值为 0
    字符串数组    默认值为 ""
    bool数组     默认值为 false
    ```
5. 使用数组的步骤
    1. 声明数组开辟空间
    2. 给数组各个元素赋值（默认零值）
    3. 使用数组
6. 数组的下标是从 0 开始的
7. 数组下标必须在指定范围内使用，否则报 panic: 数组越界，比如 var arr [5]int，则有效下标为 0 - 4
8. Go 的数组属值类型，在默认情况下是值传递，因此会进行值拷贝。数组间不会相互影响。
9. 如想在其它函数中，去修改原来的数组，可以使用引用传递（指针方式）
10. 长度是数组类型的一部分，在传递函数参数时，需要考虑数组的长度。

## 切片

1. 切片的英文是 slice
2. 切片是数组的一个引用，因此切片是引用类型，在进行传递时，遵守引用传递的机制。
3. 切片的使用和数组类似，遍历切片、访问切片的元素和求切片长度 len(slice) 都一样。
4. 切片的长度是可以变化的，因此切片是一个可以动态变化数组。
5. 切片定义的基本语法：
    ```
    var 切片名 []类型
    var a []int
    
    var a []int = make([]int, len, capacity)
    var a []int = []int{}
    ```
6. 切片的底层结构
    ```
    type slice struct {
    	array unsafe.Pointer // 指向数组的指针
    	len   int            // 当前切片的长度
    	cap   int            // 当前切片的容量
    }
    ```
7. 个人理解，切片的操作实际上都是对指针的操作，重点思考指针指向的是哪块内存空间（扩容前旧的内存空间还是扩容后新的内存空间？）。

## 映射

1. 基本语法
    ```
    var 变量名 map[keyType]valueType
    var m map[string]string
    
    var m map[string]string = make(map[string]string)
    var m map[string]string = map[string]string{}
    ```
2. map使用细节
    1. map 是引用类型，遵守引用类型传递的机制，在一个函数接收map，修改后，会直接修改原来的map。
    2. map 的容量达到后，在向 map 增加元素，会自动扩容，并不会发生 panic，也就是说 map 能动态增长键值对（key-value）。
    3. map 的 value 也经常使用 struct 类型，更适合管理复杂的数据（比前面value是一个map更好），比如 value 为 Student 结构体。

## 面向对象编程

1. Golang 也支持面向对象编程（OOP），但是和传统的面向对象编程有区别，并不是存粹的面向对象语言。所以我们说 Golang 支持面向对象编程特性是比较准确的。
2. Golang 没有类（class），Go语言的结构体（struct）和其它编程语言的类（Class）有同等的地位，你可以理解Golang是基于 struct 来实现 OOP 特性的。
3. Golang 面向对象编程非常简洁，去掉了传统 OOP 语言的继承、方法重载、构造函数和析构函数、隐藏的 this 指针等等。
4. Golang 仍然有面向对象编程的继承，封装和多态的特性，只是实现的方式和其它的OOP语言不一样，比如继承：Golang 没有 extends 关键字，继承是通过匿名字段来实现。
5. Golang 面向对象（OOP）很优雅，OOP本身就是语言类型系统（type system）的一部分，通过接口（interface）关联，耦合性低，也非常灵活。

### 结构体

1. 基本语法
    ```
    type 结构体名称 struct {
        field1 type
        field2 type
    }
    
    type Student struct {
        Name string
        Age int
        Score float64
    }
    
    var stu Student
    var stu Student = Student{}
    var stu *Student = new(Student)
    var stu *Student = &Student{}
    说明
    1. 第3中和第4中方式返回的是 结构体指针。
    2. 结构体指针访问字段的标准方式应该是：(*结构体指针).字段名，比如 (*person).Name = "tom"
    3. 但go做了一个简化，也支持 结构体指针.字段名，比如 person.Name = "tom"。更加符合程序员使用的习惯，go编译器底层对 person.Name 做了转化 (*person).Name。
    ```
2. 注意事项和细节说明
    1. 字段声明语法同变量
    2. 字段的类型可以为 基本类型、数组或引用类型
    3. 在创建一个结构体变量后，如果没有给字段赋值，都对应一个零值（默认值）
        ```
        数据类型        默认值
        bool           false
        int/float/byte 0
        string         ""
        数组           默认值与他的元素类型相关 [false] [0] [""] [nil]
        指针           nil，即没有分配空间
        slice         nil，即没有分配空间
        map           nil，即没有分配空间
        ```
    4. 不同结构体变量的字段是独立，互不影响，一个结构体变量字段的更改，不影响另外一个，结构体是值类型。
3. 结构体使用注意事项和细节
    1. 结构体的所有字段在内存中是连续的。
    2. 结构体是用户单独定义的类型，和其它类型进行转换时需要有完全相同的字段（名字、个数和类型）
    3. 结构体进行type重新定义（相当于取别名），Golang认为是新的数据类型，但是相互间可以强转。
    4. struct 的每个字段上，可以写上一个 tag，该 tag 可以通过反射机制获取，常见的使用场景就是序列化和反序列化。

### 方法

1. Golang 中的方法是作用在指定的数据类型上的（即：和指定的数据类型绑定），因此自定义类型，都可以有方法，而不仅仅是 struct。
2. 方法的声明（定义）
    ```
    func (recevier type) methodName(参数列表) (返回值列表) {
        方法体
        return 返回值
    }
    1. 参数列表：表示方法输入
    2. recevier type：表示这个方法和 type 这个类型进行绑定，或者说该方法作用于 type 类型
    3. recevier type：type 可以是结构体，也可以其它的自定义类型
    4. recevier：就是 type 类型的一个变量（实例），比如：Person 结构体的一个变量（实例）
    5. 返回值列表：表示返回的值，可以多个
    6. 方法主体：表示为了实现某一功能代码块
    7. return 语句不是必须的。
    ```
3. 方法的注意事项和细节
    1. 结构体类型是值类型，在方法调用中，遵守值类型的传递机制，是值拷贝传递方式。
    2. 如程序员希望在方法中，修改结构体变量的值，可以通过结构体指针的方式来处理。
    3. Golang 中的方法作用在指定的数据类型上的（即和指定的数据类型绑定），因此自定义类型，都可以有方法，而不仅仅是struct，比如int，float32 等都可以有方法。
    4. 方法的访问范围控制的规则，和函数一样。方法名首字母小写，只能在本包访问，方法首字母大写，可以在本包和其它包访问。
    5. 如果一个类型实现了 String() 这个方法，那么 fmt.Println 默认会调用这个变量的 String() 进行输出。
4. 方法和函数区别
    1. 调用方式不一样
        1. 函数的调用方式： 函数名(实参列表)
        2. 方法的调用方式： 变量.方法名(实参列表)
    2. 对于普通函数，接收者为值类型是，不能将指针类型的数据直接传递，反之亦然
    3. 对于方法（如struct的方法），接收者为值类型时，可以直接用指针类型的变量调用方法，反过来同样也可以。
5. 总结
    1. 不管调用形式如何，真正决定是值拷贝还是地址拷贝，看这个方法是和哪个类型绑定。
    2. 如果是和值类型，比如(p Person)，则是值拷贝，如果是和指针类型，比如(p *Person)，则是地址拷贝。
6. [Should I define methods on values or pointers?](https://golang.org/doc/faq#methods_on_values_or_pointers)
    ```
    func (s *MyStruct) pointerMethod() {} // method on pointer
    func (s MyStruct) valueMethod()    {} // method on value
    
    对于不熟悉指针的程序员来说，这两个示例之间的区别可能会令人混淆，但实际情况非常简单。在类型上定义方法时，接收方(上面例子中的s)的行为与方法的参数完全一样。将接收方定义为值还是指针，这与函数参数应该是值还是指针是同一个问题。有几点需要考虑。
            
    首先，也是最重要的，该方法是否需要修改接收方?如果是，接收器必须是指针。(切片和映射作为引用，所以它们的故事稍微微妙一些，但是，例如要改变方法中切片的长度，接收者必须仍然是一个指针。)在上面的例子中，如果pointerMethod修改了s的字段，调用者将看到这些更改，但是valueMethod是使用调用者的参数的副本调用的(这是传递值的定义)，所以它所做的更改对调用者来说是不可见的。
    
    顺便说一下，在Java方法中，接收器总是指针，尽管它们的指针本质有些隐藏(有人建议在语言中添加值接收器)。Go中的值接收器是不寻常的。
    
    其次是对效率的考虑。如果接收器很大，比如结构很大，使用指针接收器会便宜很多。
    
    下一个是一致性。如果该类型的一些方法必须具有指针接收器，那么其他方法也应该具有指针接收器，因此无论如何使用该类型，方法集都是一致的。有关详细信息，请参阅方法集一节。
    
    对于基本类型、切片和小structs等类型，值接收器非常便宜，因此除非方法的语义需要指针，否则值接收器是高效和清晰的。
    ```

### 面向对象编程

1. 封装
    1. 将结构体、字段（属性）的首字母小写（不能导出了，其他包也不能使用，类似private）
    2. 给结构体所在包提供一个工厂模式的函数，首字母大写。类似一个构造函数。
    3. 提供一个首字母大写的 Set方法（类似其它语言的public），用于对属性判断并赋值。
        ```
        func (s *MyStruct) SetXxx(参数列表) (返回值列表) {...}
        ```
    4. 提供一个首字母大写的 Get方法（类似于其他语言的public），用于获取属性的值。
        ```
        func (s *MyStruct) GetXxx(参数列表) (返回值列表) {...}
        ```
2. 继承
    1. 在 Golang 中，如果一个 struct 嵌套了另一个匿名结构体，那么这个结构体可以直接访问匿名结构体的字段和方法，从而实现了继承特性。
    2. 嵌套匿名结构体的基本语法
        ```
        type Goods struct {
            Name string
            price int
        }
        
        type Book struct {
            Goods // 这里就是嵌套匿名结构体Goods
            Writer string
        }
        ```
    3. 继承的深入讨论
        1. 结构体可以使用嵌套匿名结构体所有的字段和方法，即：首字母大写或者小写的字段、方法，都可以使用。
        2. 匿名结构体字段访问可以简化
        3. 当结构体和匿名结构体有相同的字段或者方法时，编译器采用就近原则访问，如希望访问匿名结构体的字段和方法，可以通过匿名结构体名来区分。
        4. 结构体嵌入两个（或多个）匿名结构体，如两个匿名结构体有相同的字段和方法（同时结构体本身没有同名的字段和方法），在访问时，就必须明确指定匿名结构体名字，否则编译报错。
        5. 如果一个 struct 嵌套了一个有名结构体，这种模式就是组合，如果是组合关系，那么就访问组合的结构体的字段或方法时，必须带上结构体的名字。
        6. 嵌套匿名结构体后，也可以在创建结构体变量（实例）时，直接指定各个匿名结构体字段的值。
            1. 如果一个结构体有 int 类型的匿名字段，就不能第二个。
            2. 如果需要有多个 int 的字段，则必须给 int 字段指定名字。
    4. 多重继承
        1. 如一个 struct 嵌套了多个匿名结构体，那么该结构体可以直接访问嵌套的匿名结构体的字段和方法，从而实现了多重继承。
        2. 多重继承细节说明
            1. 如嵌入的匿名结构体有相同的字段名或者方法名，则在访问时，需要通过匿名结构体类型名来区分。
            2. 为了保证代码的简洁性，建议大家尽量不使用多重继承。

### 接口

1. interface类型可以定义一组方法，但是这些不需要实现。并且 interface 不能包含任何变量。到某个自定义类型（比如结构体Phone）要使用的时候，在根据具体情况把这些方法写出来（实现）。
2. 基本语法
    ```
    type 接口名 interface {
        method1(参数列表) (返回值列表)
        method2(参数列表) (返回值列表)
    }
    
    func (s *MyStruct) method1(参数列表) (返回值列表) {}
    func (s *MyStruct) method2(参数列表) (返回值列表) {}
    ```
3. 说明
    1. 接口里的所有方法都没有方法体，即接口的方法都是没有实现的方法。接口体现了程序设计的多台和高内聚低耦合的思想。
    2. Golang 中的接口，不需要显式的实现。只要一个变量，含有接口类型中的所有方法，那么这个变量就实现这个接口。因此，Golang 中没有 implement 这样的关键字。
4. 注意事项和细节
    1. 接口本身不能创建实例，但是可以指向一个实现了该接口的自定义类型的变量（实例）。
    2. 接口中所有的方法都没有方法体，即都是没有实现的方法。
    3. 在 Golang 中，一个自定义类型需要将某个接口的所有方法都实现，我们说这个自定义类型实现了该接口。
    4. 一个自定义类型只有实现了某个接口，才能将该自定义类型的实例（变量）赋给接口类型。
    5. 只要是自定义数据类型，就可以实现接口，不仅仅是结构体类型。
    6. 一个自定义类型可以实现多个接口。
    7. Golang 接口中不能有任何变量。
    8. 一个接口（比如A接口）可以继承多个别的接口（比如B,C接口），这时如果要实现A接口，也必须将B,C接口的方法也全部实现。
    9. interface 类型默认是一个指针（引用类型），如果没有对interface初始化就使用，那么会输出 nil。
    10. 空接口 interface{} 没有任何方法，所以所有类型都实现了空接口，即我们可以把任何一个变量赋给空接口。
5. [Why is my nil error value not equal to nil?](https://golang.org/doc/faq#nil_error)
    ```
    在幕后，接口被实现为两个元素，类型T和值V。V是具体值，例如int，struct或指针，从来都不是接口本身，并且具有类型T。例如，如果我们将int值3存储在一个接口，则生成的接口值的示意图为（T = int，V = 3）。 值V也称为接口的动态值，因为给定的接口变量在程序执行期间可能拥有不同的值V（和对应的类型T）。
    
    只有当V和T都未设置时，接口值才为nil (T=nil, V未设置)，特别是，nil接口将始终保持nil类型。如果我们将类型为*int的nil指针存储在一个接口值中，那么内部类型将是*int，而不管指针的值是多少:(T=*int, V=nil)。因此，这样的接口值将是非nil，即使其中的指针值V为nil。
    ```

## 类型断言

1. 基本语法
    ```
    y, ok := x.(float32)
    
    switch x.(type) {
    case bool:
        ...
    }
    ```

## 协程

1. Go协程和Go主线程
    1. Go主线程：一个Go线程上，可以起多个协程，你可以这样理解，协程是轻量级的线程。
    2. Go协程的特点：
        1. 有独立的栈空间
        2. 共享程序堆空间
        3. 调度由用户控制
        4. 协程是轻量级的线程
2. goroutine 的调度模型
    1. MPG模式基本介绍
        1. M：操作系统的主线程（是物理线程）
        2. P：协程执行需要的上下文
        3. G：协程
3. channel(管道)
    1. 不同 goroutine 之间如何通讯
        1. 全局变量的互斥锁
        2. 使用管道 channel 来解决
    2. channel的基本介绍
        1. channel 本质就是一个数据结构 - 队列
        2. 数据是先进先出的【FIFO】
        3. 线程安全，多goroutine访问时，不需要加锁，就是说 channel 本身就是线程安全的
        4. channel 有类型的，一个 string 的 channel 只能存放 string 类型数据
    3. 定义/声明 channel
        ```
        var 变量名 chan 数据类型
        var intChan chan int
        var mapChan chan map[int]string
        var perChan chan Person
        var perPtrChan chan *Person
        
        说明
        1. channel 是引用类型
        2. channel 必须初始化才能写入数据，即 make 后才能使用
        3. 管道是有类型的，intChan 只能写入整数 int
        ```
    4. channel 使用的注意事项
        1. channel 中只能存放指定的数据类型
        2. channel 的数据放满后，就不能在放入了
        3. 如果从 channel 取出数据后，可以继续放入
        4. 在没有使用协程的情况下，如果 channel 数据取完了，再取，就会报 deadlock
    5. channel 的遍历和关闭
        1. channel 的关闭
            1. 使用内置函数 close 可以关闭 channel，当 channel 关闭后，就不能再向 channel 写数据了，但是仍然可以从该 channel 读取数据
        2. channel 的遍历
            1. channel 支持 for-range 的方式进行遍历，请注意两个细节
                1. 在遍历时，如果 channel 没有关闭，则会出现 deadlock 的错误
                2. 在遍历时，如果 channel 已经关闭，则会正常遍历数据，遍历完后，就会退出遍历。
    6. channel 使用细节和注意事项
        1. channel 可以声明为只读，或者只写性质。
        2. channel 只读和只写的最佳实践案例，多用于方法参数类型
            ```
            var ch = make(chan int, 10)
            func send(ch chan<- int) {...}
            func recv(ch <-chan int) {...}
            ```
        3. 使用 select 可以解决从管道取数据的阻塞问题
        4. goroutine 中使用recover，解决协程中出现 panic，导致程序崩溃问题

## 反射

1. 反射的基本介绍
    1. 反射可以在运行时动态获取变量的各种信息，比如变量的类型（type），类别（kind）
    2. 如果是结构体变量，还可以获取到结构体本身的信息（包括结构体的字段、方法）
    3. 通过反射，可以修改变量的值，可以调用关联的方法。
    4. 使用反射，需要 import "reflect"
2. 反射的应用场景
    1. 不知道接口调用哪个函数，根据传入参数在运行时确定调用的具体接口，这种需要对函数或方法反射。
    2. 对结构体序列化时，如果结构体有指定Tag，也会使用到反射生成对应的字符串。
3. 反射重要的函数和概念
    1. reflect.TypeOf(变量名)，获取变量的类型，返回 reflect.Type 类型
    2. reflect.ValueOf(变量名)，获取变量的值，返回 reflect.Value 类型。reflect.Value 是一个结构体类型，通过 reflect.Value，可以获取到关于该变量的很多信息。
    3. 变量、interface{} 和 reflect.Value 是可以相互转换的，这点在实际开发中，会经常使用到。
4. 反射的注意事项和细节
    1. reflect.Value.Kind，获取变量的类别，返回的是一个常量。
    2. Type 和 Kind 的区别
        1. Type 是类型，Kind 是类别，Type 和 Kind 可能是相同的，也可能是不同的。
            ```
            比如 var num int = 10     num 的 Type 是 int，Kind 也是 int
            比如 var stu Student      stu 的 Type 是 包名.Student，Kind 是 struct
            ```
    3. 通过反射可以在让变量在 interface{} 和 Reflect.Value 之间相互转换。
        ```
        变量 <----> interface{} <----> reflect.Value
        ```
    4. 使用反射的方式来获取变量的值（并返回对应的类型），要求数据类型匹配，比如 x 是 int，那么就应该使用 reflect.Value(x).Int()，而不能使用其他的，否则报 panic。
    5. 通过反射的来修改变量，注意当使用 SetXxx 方法来设置需要通过对应的指针类型来完成，这样才能改变传入的变量的值，同时需要使用到 reflect.Value.Elem() 方法。
5. 反射最佳实践
    1. 使用反射来遍历结构体的字段，调用结构体的方法，并获取结构体标签的值。
    2. 使用反射的方式来获取结构体的 tag 标签，遍历字段的值，修改字段值，调用结构体方法。
    3. 定义了两个函数 test1 和 test2，定义一个适配器函数用作统一处理接口
    4. 使用反射操作任意结构体类型
    5. 使用反射创建并操作结构体

## 网络编程

1. 网络编程基本介绍
    1. 网络编程有两种：
        1. TCP socket编程，是网络编程的主流。之所以叫Tcp Socket编程，是因为底层是基于 tcp/ip 协议的。
        2. b/s 结构的 http 编程，我们使用浏览器去访问服务器时，使用的就是 http 协议，而 http 底层依旧使用 tcp socket实现的。
2. 协议 tcp/ip
    1. TCP/IP(Transmission Control Protocol/Internet Protocol)的简写，中文译名为传输控制协议/因特网互联协议，又叫网络通讯协议，这个协议是 Internet 最基本的协议、Internet 国际互联网络的基础，简单的说，就是由网络层的 IP协议和传输层的 TCP协议组成的。
    2. OSI 与 TCP/IP 参考模型
        1. OSI模型（理论）：物理层（Physical Layer） - 数据链路层（Data Link Layer） - 网络层（Network Layer） - 传输层（Transport Layer） - 会话层（Session Layer） - 表示层（Presentation Layer） - 应用层（Application Layer）
        2. TCP/IP模型（现实）：链路层（与硬件驱动对话） - 网络层（定位ip地址和确定连接路径） - 传输层（解释数据） - 应用层（smtp，ftp，telnet，http）
3. ip地址
    1. 概述：每个 internet 上的主机和路由器都有一个ip地址，它包括网络号和主机号，ip地址有 ipv4(32位)或者 ipv6(128位)。
4. 端口
    1. 分类
        1. 0号是保留端口
        2. 1-1024 是固定端口（程序员不要使用），又叫有名端口，即被某些程序固定使用，一般程序员不使用。
            1. 22: SSH远程登录协议
            2. 23: telnet使用
            3. 21: ftp使用
            4. 25: smtp服务使用
            5. 80: iis使用
            6. 7: echo服务
        3. 1025-65535是动态端口
    2. 使用注意
        1. 在计算机（尤其是做服务器）要尽可能的少开端口
        2. 一个端口只能被一个程序监听
        3. [netstat](https://www.cnblogs.com/peida/archive/2013/03/08/2949194.html)

5. tcp socket编程的客户端和服务器端
    1. 服务端的处理流程
        1. 监听端口 8888
        2. 接收客户端的tcp连接，建立客户端和服务器端的连接。
        3. 创建 goroutine，处理该连接的请求（通常客户端会通过连接发送请求包）
    2. 客户端的处理流程
        1. 建立与服务器段的连接
        2. 发送请求数据【终端】，接收服务器端返回的结果。
        3. 关闭连接

## Redis

### Redis的使用

1. Redis 基本介绍
2. Redis 的基本使用
    1. Redis 安装好后，默认有 16个数据库，初始默认使用 0号库，编号是 0 - 15
3. Redis 的 CRUD 操作
    1. Redis 的五大数据类型
        1. Redis的五大数据类型是：String(字符串)、Hash(哈希)、List(列表)、Set(集合)和Zset(有序集合)
    2. String(字符串)
        1. string是redis最基本的类型，一个key对应一个value
        2. string类型是二进制安全的。除普通的字符串外，也可以存放图片等数据。
        3. redis中字符串value最大是512M
    3. Hash(哈希)
        1. Redis hash是一个键值对集合。
        2. Redis hash是一个string类型的field和value的映射表，hash特别适合用户存储对象。
    4. List（列表）
        1. 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）
        2. List本质是个链表，List的元素是有序的，元素的值可以重复。
    5. Set(集合)
        1. Redis的Set是string类型的无需集合。
        2. 底层是 HashTable 数据结构，Set 也是存放很多字符串元素，字符串元素是无序的，而且元素的值不能重复。

### Golang 操作 Redis

## Golang 下载第三方包

```
#设置代理
alias go='http_proxy=socks5://127.0.0.1:1080 https_proxy=socks5://127.0.0.1:1080 go'

#go get
go get -t -v golang.org/x/crypto/ripemd160
```

